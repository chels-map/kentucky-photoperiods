<!DOCTYPE html>
<html>

<head>
  <meta charset=utf-8 />
  <title>MAP672 Final Maupin</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
  integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
  crossorigin=""/>
  <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>

  <style>
    body {
      margin: 0;
      padding: 0;
      background: rgb(37, 51, 131);
      font-family: Lato, sans-serif;
      color: #e6e6e6;
    }

    header {
      width: 80%;
      margin: 10px auto 10px auto;
    }

    h1 {
      display: inline-block;
      margin-right: 20px;
      color: #e6e6e6;
    }

    h2 {
      display: inline-block;
      color: #e6e6e6;
    }

    #map {
      width: 80%;
      height: 540px;
      margin: 10px 10%;
      background: rgb(245, 244, 236);
      border: 2px solid #ecdf20;
    }

    footer {
      padding: 6px 10%;
      width: 80%;
    }

    p {
      font-size: 1em;
      color: #ffffff;
    }

    .legend {
        padding: 6px 8px;
        font-size: 1em;
        background: rgba(255,255,255,0.8);
        box-shadow: 0 0 15px rgba(0,0,0,0.2);
        border-radius: 5px;
    }
    .legend h3 {
        font-size: 1.1em;
        font-weight: normal;
        color: #001323;
        margin: 0 0 10px 0;
    }
    .legend span {
        width: 20px;
        height: 20px;
        float: left;
        margin: 0 10px 4px 0;
    }
    .legend label {
        font-size: 1.1em;
    }
    .legend label:after {
        content: '';
        display: block;
        clear: both;
    }
  </style>
</head>

<body>
  <header>
    <h1>Photoperiod in Kentucky</h1>
    <h2>June 2020</h2>
  </header>

  <div id='map'></div>

  <footer>
    <p>Map authored by Chelsea Maupin</p>
    <p>The data  <a href = "https://data.census.gov/cedsci/">US Census Cartographic Boundary Shapefiles</a>, provided thanks to the 
    New Maps Plus program at University of Kentucky.</p>

  </footer>

  <!-- Load scripts using Subresource Integrity (SRI) is a security feature 
      that enables browsers to verify that resources they fetch 
      (from a CDN) are delivered without unexpected manipulation. -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
    integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
    crossorigin=""></script>
  <script src='https://unpkg.com/simple-statistics@7.6.0/dist/simple-statistics.min.js'>
  </script>

  <script>

//------------------CODE FOR REGULAR MAP------------------------
    // var options = {
    //     center: [37.8, -85.8],
    //     zoom: 7.4,
    //     zoomSnap: .1,
    //     zoomControl: false
    // }
    // var map = L.map('map', options);

//------------------CODE TO ADD TILESET------------------------
    // Create Leaflet map with above options.
    var map = L.map('map', options);

    // Get basemap URL from Leaflet Providers BUT NOW from my file?
    var basemap_url = 'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.{ext}'

    // Get basemap attributes from Leaflet Providers
    var basemap_attributes = {
      attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
	    subdomains: 'abcd',
	    minZoom: 6,
    	 maxZoom: 14,
	    ext: 'png'
    }

    // Add tileset as a layer in our map. 
    var tiles = L.tileLayer(basemap_url, basemap_attributes).addTo(map);


    var countyLayer = $.getJSON("data/ky_county_boundaries.geojson", function(data) {
      var dataLayer = L.geoJson(data, {
        style: function(feature) {
          return {
              color: '#dddddd',
              weight: 1,
              fillOpacity: 1,
              fillColor: 'green' 
          };
        }
            
      }).addTo(map);
      drawAnotherLayer()
      // call to new function here gets the data out of the callback function
    //   drawMap(dataLayer); 
    });


    // function drawMap(dataLayer) {
    //    var breaks = getClassBreaks(dataLayer);
    //    dataLayer.eachLayer(function(layer) {
        
    //     var props = layer.feature.properties;

    //     layer.setStyle({
    //       fillColor: getColor(props[rent], breaks) //CHANGE VALUE
    //      });
    //   });
    //    //drawLegend(breaks) 
    //  }


    // function getClassBreaks(dataLayer) {
    //   // create empty Array for storing values
    //   var values = [];
    //   dataLayer.eachLayer(function(layer) {       // loop through all the counties
    //     var props = layer.feature.properties;
    //     if(props[rent] != null){
    //     var value = props[rent]; //CHANGE VALUE!! 
    //     values.push(value);  
    //     }
    //   });

    //   var clusters = ss.ckmeans(values, 5);  // determine similar clusters, create an array of the lowest value within each cluster
    //                                            //Gives us the lower bound/upper bound of each cluster
    //   var breaks = clusters.map(function(cluster){
    //     return [cluster[0],cluster.pop()];   
    //   });
    //       console.log(breaks);
    //       return breaks; // return Array of class breaks
    // }                // end getClassBreaks function

      //Have more expensive be a darker color
      //Colors are ordered correctly in the function and yet it doesn't seem
      //to be applying correctly....

    //   function getColor(d, breaks) {
    //         if(d <= breaks[0][1]) {
    //             return '#f1eef6';
    //         } else if(d <= breaks[1][1]) {
    //             return '#bdc9e1';
    //         } else if(d <= breaks[2][1]) {
    //             return '#74a9cf';
    //         } else if(d <= breaks[3][1]) {
    //             return '#2b8cbe'
    //         } else if(d <= breaks[4][1]) {
    //             return '#045a8d'
    //         }
    //     } 


    // //ADD LEGEND      
    // function drawLegend(breaks){
    //   // create a new Leaflet control object, and position it top left
    //   var legend = L.control({position: 'topleft'});
    //   // when the legend is added to the map
    //   legend.onAdd = function () {
    //       // create a new HTML <div> element and give it a class name of "legend"
    //       var div = L.DomUtil.create('div', 'legend');

    //       // first append an <h3> tag to the div holding the current attribute
    //       // and norm values (i.e., the mapped phenomena)
    //       div.innerHTML = `<h3>$${rent} in ${name}</h3>`;

    //       // for each of our breaks
    //       for (var i = 0; i < breaks.length; i++) {
    //           // determine the color associated with each break value,
    //           // including the lower range value
              
    //           var color = getColor(breaks[i][0], breaks);

    //           // concatenate a <span> tag styled with the color and the range values
    //           // of that class and include a label with the low and a high ends of that class range
    //           div.innerHTML +=
    //               `<span style="background:${color}"></span>
    //               <label>${(breaks[i][0]*100).toLocaleString()}&mdash;
    //               ${(breaks[i][1]*100).toLocaleString()}</label>`;
    //       }
    //       // return the populated div to be added to the map
    //       return div;
    //   };
    //   // add the legend to the map
    //   legend.addTo(map);
    // }

    //Adding city points, will add layer name
    //WHOA this takes forever to load, maybe I could add just the 10-15 biggest cities to the map?
    //Look up top 10 cities, then filter based on the city name? 
    var cityPoints = $.getJSON("data/JunePhotoperiodKY.geojson", function(data) {
        var cityPoints = L.geoJson(data, {
            pointToLayer: function (feature, latlng){
                return L.circleMarker(latlng);
            },
            style: function(feature) {
                return {
                    color: '#000000',
                    weight: 1,
                    fillOpacity: 1,
                    radius: 5
                }
            },
            onEachFeature : function(feature,layer){
            layer.on('mouseover', function() {
              layer.setStyle({
                color: 'yellow',
                fillColor: 'yellow'
              });
            });
            layer.on('mouseout', function() {
              layer.setStyle({
                color: '#000000',
                fillColor: '#000000'
              });
            });	

          // name of power plant in toolip
          layer.bindTooltip(`<b>${feature.properties.City}</b><br>
                            <b>Photoperiod:</b>${feature.properties.Duration}(%Day${feature.properties.percentDay})<br>
                            Zip code: ${feature.properties.Zip}<br>
                            A way to add County name?`);
          //Photoperiod is encoded as a STRING
          //Need to change to a numeric value
          console.log(typeof feature.properties.percentDay)

          }
     
        }).addTo(map);
   });

    // // Tell jQuery to wait until data is loaded before executing a function
    // $.when(countyLayer).done(function () {
    // // load, filter, and style the state outline 
    // $.getJSON("data/us_states_500k.geojson", function (data) {

    //     var stateLayer = L.geoJson(data, {
    //         style: function (feature) {
    //         return {
    //             // Let's experiment with these colors shortly
    //             // color: '#222222', // Gray
    //             color: '#ffffff', // White
    //             // Make line weight larger than the county outline
    //             weight: 2,
    //             fillOpacity: 0,
    //             // This property allows us control interactivty of layer
    //             interactive: false
    //         };
    //         },

    //         // Filter for the correct state to use
    //         filter: function (feature) {
    //         if (feature.properties.NAME == "Kentucky") {
    //             return feature;
    //         }
    //         }
    //     });

    //     // Add layer to map!
    //     stateLayer.addTo(map)

    //  });
    // });


//FETCH!
// // Make the call to external data
// fetch('data/ky_counties_housing.json')
//   // When the server responds, let's evaluate the response
//   .then(function (response) {
//     // Look at the response
//     console.log(response)
//     // The API call was successful!
//     if (response.ok) {
//         // Parse the response as a JSON and return it
//         return response.json() 
//     } else { 
//         // Present the numeric status code if it fails. 
//         throw new Error(`HTTP error! status: ${response.status}`);
//     }
//   })
//   // Pass the returned value of previous .then() method as 'data'
//   .then(function (data) {
//     // Draw basic map from data
//     var dataLayer = L.geoJson(data, {
//       style: function (feature) {
//         return {
//           color: 'white',
//           weight: 1,
//           fillOpacity: 1,
//           fillColor: '#1f78b4'
//         };
//       }
//     }).addTo(map)
//     // Make call to update map
//     drawMap(dataLayer);
//   })
//   .then(function () {
//     // Draw another layer after the previous .then() resolves
//     drawAnotherLayer()
//   })
  

  // Define a function that fetches data and then draws another layer
  function drawAnotherLayer() {
    fetch("data/ky_bordering_states.geojson").then(function (response) {
      if (response.ok) {
        // Parse the response as a JSON and return it
        return response.json() 
      }
    })
    .then(function(data) {
      L.geoJson(data,{
        style: function (feature) {
          return {
            color: '#444',
            weight: 2,
            fillOpacity: 0,
            interactive: false
          };
        }
        // filter: function (feature) {
        //   console.log(feature.properties.NAME)
        //   if (feature.properties.NAME == ("Kentucky" && "Indiana" && "Ohio")) {
        //     return feature;
        //   }
        // }
      }).addTo(map)
    })
  }




    //Add Zoom control
    map.addControl( L.control.zoom({ position: 'topright' }));

  </script>

</body>

</html>